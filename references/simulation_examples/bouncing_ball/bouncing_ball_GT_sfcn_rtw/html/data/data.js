var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"bouncing_ball_GT","ref":false,"files":[{"name":"bouncing_ball_GT_sf.c","type":"source","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * bouncing_ball_GT_sf.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"bouncing_ball_GT_sf.h\"\n#include \"rtwtypes.h\"\n#include \"bouncing_ball_GT_sf_private.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\n\nextern void *bouncing_ball_GT_malloc(SimStruct *S);\n\n#endif\n\n#ifndef __RTW_UTFREE__\n#if defined (MATLAB_MEX_FILE)\n\nextern void * utMalloc(size_t);\nextern void utFree(void *);\n\n#endif\n#endif                                 /* #ifndef __RTW_UTFREE__ */\n\n#if defined(MATLAB_MEX_FILE)\n#include \"rt_nonfinite.c\"\n#endif\n\nstatic const char_T *RT_MEMORY_ALLOCATION_ERROR =\n  \"memory allocation error in generated S-Function\";\n\n/* System initialize for root system: '<Root>' */\n#define MDL_INITIALIZE_CONDITIONS\n\nstatic void mdlInitializeConditions(SimStruct *S)\n{\n  if (ssIsFirstInitCond(S)) {\n    X_bouncing_ball_GT_T *_rtX;\n    _rtX = ((X_bouncing_ball_GT_T *) ssGetContStates(S));\n\n    /* InitializeConditions for Memory: '<Root>/Memory' */\n    ((real_T *)ssGetDWork(S, 0))[0] = 0.0;\n\n    /* InitializeConditions for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n    _rtX->Position[0] = 25.0;\n    ((int_T *)ssGetDWork(S, 1))[0] = 0;\n    ((boolean_T *)ssGetDWork(S, 3))[0] = true;\n  } else {\n    X_bouncing_ball_GT_T *_rtX;\n    _rtX = ((X_bouncing_ball_GT_T *) ssGetContStates(S));\n\n    /* InitializeConditions for Memory: '<Root>/Memory' */\n    ((real_T *)ssGetDWork(S, 0))[0] = 0.0;\n\n    /* InitializeConditions for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n    _rtX->Position[0] = 25.0;\n    ((int_T *)ssGetDWork(S, 1))[0] = 0;\n    ((boolean_T *)ssGetDWork(S, 3))[0] = true;\n  }\n}\n\n/* Start for root system: '<Root>' */\n#define MDL_START\n\nstatic void mdlStart(SimStruct *S)\n{\n  /* instance underlying S-Function data */\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\n#if defined(MATLAB_MEX_FILE)\n\n  /* non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* Check for invalid switching between solver types */\n  if (ssIsVariableStepSolver(S)) {\n    ssSetErrorStatus(S, \"This Simulink Coder generated \"\n                     \"S-Function cannot be used in a simulation with \"\n                     \"a solver type of variable-step \"\n                     \"because this S-Function was created from a model with \"\n                     \"solver type of fixed-step and it has continuous time blocks. \"\n                     \"See the Solver page of the simulation parameters dialog.\");\n    return;\n  }\n\n  if (fabs(ssGetFixedStepSize(S) - 0.5) > mxGetEps()*100*0.5) {\n    ssSetErrorStatus(S, \"This Simulink Coder generated \"\n                     \"S-Function cannot be used in a simulation with \"\n                     \"the current fixed step size \"\n                     \"because this S-Function was created from a model with \"\n                     \"a fixed step size of 0.5 and had both \"\n                     \"continuous blocks and discrete blocks running at this rate. \"\n                     \"See the Solver page of the simulation parameters dialog.\");\n    return;\n  }\n\n#endif\n\n  bouncing_ball_GT_malloc(S);\n  if (ssGetErrorStatus(S) != (NULL) ) {\n    return;\n  }\n\n#endif\n\n  {\n    B_bouncing_ball_GT_T *_rtB;\n    _rtB = ((B_bouncing_ball_GT_T *) ssGetLocalBlockIO(S));\n\n    /* Start for InitialCondition: '<Root>/Initial Velocity (IC) ' */\n    ((boolean_T *)ssGetDWork(S, 2))[0] = true;\n  }\n}\n\n/* Outputs for root system: '<Root>' */\nstatic void mdlOutputs(SimStruct *S, int_T tid)\n{\n  B_bouncing_ball_GT_T *_rtB;\n  X_bouncing_ball_GT_T *_rtX;\n  boolean_T tmp;\n  boolean_T tmp_0;\n  _rtX = ((X_bouncing_ball_GT_T *) ssGetContStates(S));\n  _rtB = ((B_bouncing_ball_GT_T *) ssGetLocalBlockIO(S));\n  tmp = ssIsSampleHit(S, 1, 0);\n  if (tmp) {\n    /* {S!d44}InitialCondition: '<Root>/Initial Velocity (IC) ' */\n    if (((boolean_T *)ssGetDWork(S, 2))[0]) {\n      ((boolean_T *)ssGetDWork(S, 2))[0] = false;\n\n      /* {S!d40}InitialCondition: '<Root>/Initial Velocity (IC) ' */\n      _rtB->InitialVelocityIC = 0.0;\n    } else {\n      /* {S!d42}InitialCondition: '<Root>/Initial Velocity (IC) ' incorporates:\n       *  Gain: '<Root>/Coefficient of  Restitution'\n       *  Memory: '<Root>/Memory'\n       */\n      _rtB->InitialVelocityIC = -0.8 * ((real_T *)ssGetDWork(S, 0))[0];\n    }\n\n    /* {E!d44}End of InitialCondition: '<Root>/Initial Velocity (IC) ' */\n  }\n\n  tmp_0 = 1;\n  if (tmp_0) {\n    /* {S!d50}SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n    if (((boolean_T *)ssGetDWork(S, 3))[0]) {\n      _rtX->Position[1] = _rtB->InitialVelocityIC;\n    }\n\n    if (ssIsModeUpdateTimeStep(S)) {\n      switch (((int_T *)ssGetDWork(S, 1))[0]) {\n       case 0:\n        if (_rtX->Position[0] <= 0.0) {\n          _rtX->Position[0] = 0.0;\n          if (_rtX->Position[1] > 0.0) {\n            ((int_T *)ssGetDWork(S, 1))[0] = 0;\n          } else {\n            _rtX->Position[1] = 0.0;\n            ((int_T *)ssGetDWork(S, 1))[0] = 1;\n          }\n\n          if (_rtB->InitialVelocityIC > 0.0) {\n            _rtX->Position[1] = _rtB->InitialVelocityIC;\n            ((int_T *)ssGetDWork(S, 1))[0] = 0;\n          }\n\n          ssSetBlockStateForSolverChangedAtMajorStep(S);\n        }\n\n        if (_rtX->Position[0] >= (rtInf)) {\n          _rtX->Position[0] = (rtInf);\n          if (_rtX->Position[1] < 0.0) {\n            ((int_T *)ssGetDWork(S, 1))[0] = 0;\n          } else {\n            _rtX->Position[1] = 0.0;\n            ((int_T *)ssGetDWork(S, 1))[0] = 2;\n          }\n\n          if (_rtB->InitialVelocityIC < 0.0) {\n            _rtX->Position[1] = _rtB->InitialVelocityIC;\n            ((int_T *)ssGetDWork(S, 1))[0] = 0;\n          }\n\n          ssSetBlockStateForSolverChangedAtMajorStep(S);\n        }\n        break;\n\n       case 1:\n        if (_rtX->Position[0] > 0.0) {\n          if (_rtX->Position[0] >= (rtInf)) {\n            ((int_T *)ssGetDWork(S, 1))[0] = 2;\n            _rtX->Position[0] = (rtInf);\n          } else {\n            ((int_T *)ssGetDWork(S, 1))[0] = 0;\n          }\n        } else {\n          _rtX->Position[0] = 0.0;\n          _rtX->Position[1] = 0.0;\n        }\n        break;\n\n       case 2:\n        if (_rtX->Position[0] < (rtInf)) {\n          if (_rtX->Position[0] <= 0.0) {\n            ((int_T *)ssGetDWork(S, 1))[0] = 1;\n            _rtX->Position[0] = 0.0;\n          } else {\n            ((int_T *)ssGetDWork(S, 1))[0] = 0;\n          }\n        } else {\n          _rtX->Position[0] = (rtInf);\n          _rtX->Position[1] = 0.0;\n        }\n        break;\n      }\n    }\n\n    if (_rtX->Position[0] < 0.0) {\n      /* {S!d46}SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n      _rtB->Position = 0.0;\n    } else {\n      /* {S!d48}SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n      _rtB->Position = _rtX->Position[0];\n    }\n\n    /* {S!d52}SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n    _rtB->Velocity = _rtX->Position[1];\n  }\n\n  if (tmp) {\n  }\n\n  if (tmp_0) {\n  }\n\n  UNUSED_PARAMETER(tid);\n}\n\n/* Update for root system: '<Root>' */\n#define MDL_UPDATE\n\nstatic void mdlUpdate(SimStruct *S, int_T tid)\n{\n  B_bouncing_ball_GT_T *_rtB;\n  int32_T uMode;\n  _rtB = ((B_bouncing_ball_GT_T *) ssGetLocalBlockIO(S));\n  if (ssIsSampleHit(S, 1, 0)) {\n    /* {S!d60}Update for Memory: '<Root>/Memory' */\n    ((real_T *)ssGetDWork(S, 0))[0] = _rtB->Velocity;\n  }\n\n  if (1) {\n    /* {S!d62}Update for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n    ((boolean_T *)ssGetDWork(S, 3))[0] = false;\n    uMode = ((int_T *)ssGetDWork(S, 1))[0];\n    if (((int_T *)ssGetDWork(S, 1))[0] == 2) {\n      uMode = 0;\n    }\n\n    if (((int_T *)ssGetDWork(S, 1))[0] != uMode) {\n      ((int_T *)ssGetDWork(S, 1))[0] = uMode;\n      ssSetBlockStateForSolverChangedAtMajorStep(S);\n    }\n\n    /* {E!d62}End of Update for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n  }\n\n  UNUSED_PARAMETER(tid);\n}\n\n/* Derivatives for root system: '<Root>' */\n#define MDL_DERIVATIVES\n\nstatic void mdlDerivatives(SimStruct *S)\n{\n  XDot_bouncing_ball_GT_T *_rtXdot;\n  X_bouncing_ball_GT_T *_rtX;\n  _rtXdot = ((XDot_bouncing_ball_GT_T *) ssGetdX(S));\n  _rtX = ((X_bouncing_ball_GT_T *) ssGetContStates(S));\n\n  /* {S!d64}Derivatives for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' incorporates:\n   *  Constant: '<Root>/Gravitational acceleration'\n   */\n  switch (((int_T *)ssGetDWork(S, 1))[0]) {\n   case 0:\n    _rtXdot->Position[0] = _rtX->Position[1];\n    _rtXdot->Position[1] = -9.81;\n    break;\n\n   case 1:\n    _rtXdot->Position[0] = 0.0;\n    _rtXdot->Position[1] = 0.0;\n    break;\n\n   case 2:\n    _rtXdot->Position[0] = 0.0;\n    _rtXdot->Position[1] = 0.0;\n    break;\n  }\n\n  /* {E!d64}End of Derivatives for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n}\n\n/* Termination for root system: '<Root>' */\nstatic void mdlTerminate(SimStruct *S)\n{\n  UNUSED_PARAMETER(S);\n\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\n\n  if (ssGetUserData(S) != (NULL) ) {\n    rt_FREE(ssGetLocalBlockIO(S));\n  }\n\n  rt_FREE(ssGetUserData(S));\n\n#endif\n\n}\n\n#if defined(RT_MALLOC) || defined(MATLAB_MEX_FILE)\n#include \"bouncing_ball_GT_mid.h\"\n#endif\n\n/* Function to initialize sizes. */\nstatic void mdlInitializeSizes(SimStruct *S)\n{\n  ssSetNumSampleTimes(S, 2);           /* Number of sample times */\n  ssSetNumContStates(S, 2);            /* Number of continuous states */\n  ssSetNumPeriodicContStates(S, 0);   /* Number of periodic continuous states */\n  ssSetNumNonsampledZCs(S, 0);         /* Number of nonsampled ZCs */\n\n  /* Number of output ports */\n  if (!ssSetNumOutputPorts(S, 0))\n    return;\n\n  /* Number of input ports */\n  if (!ssSetNumInputPorts(S, 0))\n    return;\n  ssSetRTWGeneratedSFcn(S, 1);         /* Generated S-function */\n\n  /* DWork */\n  if (!ssSetNumDWork(S, 4)) {\n    return;\n  }\n\n  /* '<Root>/Memory': PreviousInput */\n  ssSetDWorkName(S, 0, \"DWORK0\");\n  ssSetDWorkWidth(S, 0, 1);\n\n  /* '<Root>/Second-Order  Integrator': MODE */\n  ssSetDWorkName(S, 1, \"DWORK1\");\n  ssSetDWorkWidth(S, 1, 1);\n  ssSetDWorkDataType(S, 1, SS_INTEGER);\n\n  /* '<Root>/Initial Velocity (IC) ': FirstOutputTime */\n  ssSetDWorkName(S, 2, \"DWORK2\");\n  ssSetDWorkWidth(S, 2, 1);\n  ssSetDWorkDataType(S, 2, SS_BOOLEAN);\n\n  /* '<Root>/Second-Order  Integrator': DWORK1 */\n  ssSetDWorkName(S, 3, \"DWORK3\");\n  ssSetDWorkWidth(S, 3, 1);\n  ssSetDWorkDataType(S, 3, SS_BOOLEAN);\n\n  /* Tunable Parameters */\n  ssSetNumSFcnParams(S, 0);\n\n  /* Number of expected parameters */\n#if defined(MATLAB_MEX_FILE)\n\n  if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {\n\n#if defined(MDL_CHECK_PARAMETERS)\n\n    mdlCheckParameters(S);\n\n#endif                                 /* MDL_CHECK_PARAMETERS */\n\n    if (ssGetErrorStatus(S) != (NULL) ) {\n      return;\n    }\n  } else {\n    return;                /* Parameter mismatch will be reported by Simulink */\n  }\n\n#endif                                 /* MATLAB_MEX_FILE */\n\n  /* Options */\n  ssSetOptions(S, (SS_OPTION_RUNTIME_EXCEPTION_FREE_CODE |\n                   SS_OPTION_PORT_SAMPLE_TIMES_ASSIGNED ));\n\n#if SS_SFCN_FOR_SIM\n\n  {\n    ssSupportsMultipleExecInstances(S, false);\n    ssRegisterMsgForNotSupportingMultiExecInst(S,\n      \"<diag_root><diag id=\\\"Simulink:blocks:ImplicitIterSS_SignalViewNotSupportedInside\\\" pr=\\\"d\\\"><arguments><arg type=\\\"numeric\\\">1</arg><arg type=\\\"encoded\\\">YgBvAHUAbgBjAGkAbgBnAF8AYgBhAGwAbABfAEcAVAAvAFMAZQBjAG8AbgBkAC0ATwByAGQAZQByACAAIABJAG4AdABlAGcAcgBhAHQAbwByAAAA</arg><arg type=\\\"encoded\\\">PABfAF8AaQBpAFMAUwBfAF8APgA8AC8AXwBfAGkAaQBTAFMAXwBfAD4AAAA=</arg><arg type=\\\"encoded\\\">PABfAF8AaQB0AGUAcgBCAGwAawBfAF8APgA8AC8AXwBfAGkAdABlAHIAQgBsAGsAXwBfAD4AAAA=</arg></arguments><hs><h>AAAAAAHQc0Ag</h></hs></diag></diag_root>\");\n    ssHasStateInsideForEachSS(S, false);\n  }\n\n#endif\n\n}\n\n/* Function to initialize sample times. */\nstatic void mdlInitializeSampleTimes(SimStruct *S)\n{\n  /* task periods */\n  ssSetSampleTime(S, 0, 0.0);\n  ssSetSampleTime(S, 1, 0.5);\n\n  /* task offsets */\n  ssSetOffsetTime(S, 0, 0.0);\n  ssSetOffsetTime(S, 1, 0.0);\n}\n\n#if defined(MATLAB_MEX_FILE)\n#include \"fixedpoint.c\"\n#include \"simulink.c\"\n#else\n#undef S_FUNCTION_NAME\n#define S_FUNCTION_NAME                bouncing_ball_GT_sf\n#include \"cg_sfun.h\"\n#endif                                 /* defined(MATLAB_MEX_FILE) */\n"},{"name":"bouncing_ball_GT_sf.h","type":"header","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * bouncing_ball_GT_sf.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bouncing_ball_GT_sf_h_\n#define bouncing_ball_GT_sf_h_\n#ifndef bouncing_ball_GT_sf_COMMON_INCLUDES_\n#define bouncing_ball_GT_sf_COMMON_INCLUDES_\n#include <stdlib.h>\n#define S_FUNCTION_NAME                bouncing_ball_GT_sf\n#define S_FUNCTION_LEVEL               2\n#ifndef RTW_GENERATED_S_FUNCTION\n#define RTW_GENERATED_S_FUNCTION\n#endif\n\n#include \"rtwtypes.h\"\n#include \"simstruc.h\"\n#include \"fixedpoint.h\"\n#if !defined(MATLAB_MEX_FILE)\n#include \"rt_matrx.h\"\n#endif\n\n#if !defined(RTW_SFUNCTION_DEFINES)\n#define RTW_SFUNCTION_DEFINES\n\ntypedef struct {\n  void *blockIO;\n  void *defaultParam;\n  void *nonContDerivSig;\n} LocalS;\n\n#define ssSetLocalBlockIO(S, io)       ((LocalS *)ssGetUserData(S))->blockIO = ((void *)(io))\n#define ssGetLocalBlockIO(S)           ((LocalS *)ssGetUserData(S))->blockIO\n#define ssSetLocalDefaultParam(S, paramVector) ((LocalS *)ssGetUserData(S))->defaultParam = (paramVector)\n#define ssGetLocalDefaultParam(S)      ((LocalS *)ssGetUserData(S))->defaultParam\n#define ssSetLocalNonContDerivSig(S, pSig) ((LocalS *)ssGetUserData(S))->nonContDerivSig = (pSig)\n#define ssGetLocalNonContDerivSig(S)   ((LocalS *)ssGetUserData(S))->nonContDerivSig\n#endif\n#endif                                /* bouncing_ball_GT_sf_COMMON_INCLUDES_ */\n\n#include \"bouncing_ball_GT_sf_types.h\"\n#include \"rt_nonfinite.h\"\n#include \"rtGetInf.h\"\n#include <string.h>\n#include <math.h>\n#include <stddef.h>\n#include \"rt_defines.h\"\n\n/* Block signals (default storage) */\ntypedef struct {\n  /*@[8957*/\n\n  /*@[8951*/\n  /*@[8952*/\n  real_T InitialVelocityIC;            /* '<Root>/Initial Velocity (IC) ' */\n\n  /*@]*/\n  /*@]*/\n\n  /*@[8953*/\n  /*@[8954*/\n  real_T Position;                     /* '<Root>/Second-Order  Integrator' */\n\n  /*@]*/\n  /*@]*/\n\n  /*@[8955*/\n  /*@[8956*/\n  real_T Velocity;                     /* '<Root>/Second-Order  Integrator' */\n\n  /*@]*/\n  /*@]*/\n\n  /*@]*/\n} B_bouncing_ball_GT_T;\n\n/* Continuous states (default storage) */\ntypedef struct {\n  /*@[8958*/\n  real_T Position[2];                  /* '<Root>/Second-Order  Integrator' */\n\n  /*@]*/\n} X_bouncing_ball_GT_T;\n\n/* State derivatives (default storage) */\ntypedef struct {\n  /*@[8959*/\n  real_T Position[2];                  /* '<Root>/Second-Order  Integrator' */\n\n  /*@]*/\n} XDot_bouncing_ball_GT_T;\n\n/* State disabled  */\ntypedef struct {                       /*@[895a*/\n  boolean_T Position[2];               /* '<Root>/Second-Order  Integrator' */\n\n  /*@]*/\n} XDis_bouncing_ball_GT_T;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'bouncing_ball_GT_sf'\n */\n#endif                                 /* bouncing_ball_GT_sf_h_ */\n"},{"name":"bouncing_ball_GT_sf_private.h","type":"header","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * bouncing_ball_GT_sf_private.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bouncing_ball_GT_sf_private_h_\n#define bouncing_ball_GT_sf_private_h_\n#include \"rtwtypes.h\"\n#include \"multiword_types.h\"\n#include \"bouncing_ball_GT_sf_types.h\"\n#if !defined(ss_VALIDATE_MEMORY)\n#define ss_VALIDATE_MEMORY(S, ptr)     if(!(ptr)) {\\\n ssSetErrorStatus(S, RT_MEMORY_ALLOCATION_ERROR);\\\n }\n#endif\n\n#if !defined(rt_FREE)\n#if !defined(_WIN32)\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\n free((ptr));\\\n (ptr) = (NULL);\\\n }\n#else\n\n/* Visual and other windows compilers declare free without const */\n#define rt_FREE(ptr)                   if((ptr) != (NULL)) {\\\n free((void *)(ptr));\\\n (ptr) = (NULL);\\\n }\n#endif\n#endif\n\n#if defined(MULTITASKING)\n#  error Model (bouncing_ball_GT_sf) was built in \\\nSingleTasking solver mode, however the MULTITASKING define is \\\npresent. If you have multitasking (e.g. -DMT or -DMULTITASKING) \\\ndefined on the Code Generation page of Simulation parameter dialog, please \\\nremove it and on the Solver page, select solver mode \\\nMultiTasking. If the Simulation parameter dialog is configured \\\ncorrectly, please verify that your template makefile is \\\nconfigured correctly.\n#endif\n#endif                                 /* bouncing_ball_GT_sf_private_h_ */\n"},{"name":"bouncing_ball_GT_sf_types.h","type":"header","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * bouncing_ball_GT_sf_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bouncing_ball_GT_sf_types_h_\n#define bouncing_ball_GT_sf_types_h_\n#endif                                 /* bouncing_ball_GT_sf_types_h_ */\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * multiword_types.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef MULTIWORD_TYPES_H\n#define MULTIWORD_TYPES_H\n#include \"rtwtypes.h\"\n\n/*\n * Definitions supporting external data access\n */\ntypedef int64_T chunk_T;\ntypedef uint64_T uchunk_T;\n\n/*\n * MultiWord supporting definitions\n */\ntypedef long long longlong_T;\n\n/*\n * MultiWord types\n */\ntypedef struct {\n  uint64_T chunks[2];\n} int128m_T;\n\ntypedef struct {\n  int128m_T re;\n  int128m_T im;\n} cint128m_T;\n\ntypedef struct {\n  uint64_T chunks[2];\n} uint128m_T;\n\ntypedef struct {\n  uint128m_T re;\n  uint128m_T im;\n} cuint128m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} int192m_T;\n\ntypedef struct {\n  int192m_T re;\n  int192m_T im;\n} cint192m_T;\n\ntypedef struct {\n  uint64_T chunks[3];\n} uint192m_T;\n\ntypedef struct {\n  uint192m_T re;\n  uint192m_T im;\n} cuint192m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} int256m_T;\n\ntypedef struct {\n  int256m_T re;\n  int256m_T im;\n} cint256m_T;\n\ntypedef struct {\n  uint64_T chunks[4];\n} uint256m_T;\n\ntypedef struct {\n  uint256m_T re;\n  uint256m_T im;\n} cuint256m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} int320m_T;\n\ntypedef struct {\n  int320m_T re;\n  int320m_T im;\n} cint320m_T;\n\ntypedef struct {\n  uint64_T chunks[5];\n} uint320m_T;\n\ntypedef struct {\n  uint320m_T re;\n  uint320m_T im;\n} cuint320m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} int384m_T;\n\ntypedef struct {\n  int384m_T re;\n  int384m_T im;\n} cint384m_T;\n\ntypedef struct {\n  uint64_T chunks[6];\n} uint384m_T;\n\ntypedef struct {\n  uint384m_T re;\n  uint384m_T im;\n} cuint384m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} int448m_T;\n\ntypedef struct {\n  int448m_T re;\n  int448m_T im;\n} cint448m_T;\n\ntypedef struct {\n  uint64_T chunks[7];\n} uint448m_T;\n\ntypedef struct {\n  uint448m_T re;\n  uint448m_T im;\n} cuint448m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} int512m_T;\n\ntypedef struct {\n  int512m_T re;\n  int512m_T im;\n} cint512m_T;\n\ntypedef struct {\n  uint64_T chunks[8];\n} uint512m_T;\n\ntypedef struct {\n  uint512m_T re;\n  uint512m_T im;\n} cuint512m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} int576m_T;\n\ntypedef struct {\n  int576m_T re;\n  int576m_T im;\n} cint576m_T;\n\ntypedef struct {\n  uint64_T chunks[9];\n} uint576m_T;\n\ntypedef struct {\n  uint576m_T re;\n  uint576m_T im;\n} cuint576m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} int640m_T;\n\ntypedef struct {\n  int640m_T re;\n  int640m_T im;\n} cint640m_T;\n\ntypedef struct {\n  uint64_T chunks[10];\n} uint640m_T;\n\ntypedef struct {\n  uint640m_T re;\n  uint640m_T im;\n} cuint640m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} int704m_T;\n\ntypedef struct {\n  int704m_T re;\n  int704m_T im;\n} cint704m_T;\n\ntypedef struct {\n  uint64_T chunks[11];\n} uint704m_T;\n\ntypedef struct {\n  uint704m_T re;\n  uint704m_T im;\n} cuint704m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} int768m_T;\n\ntypedef struct {\n  int768m_T re;\n  int768m_T im;\n} cint768m_T;\n\ntypedef struct {\n  uint64_T chunks[12];\n} uint768m_T;\n\ntypedef struct {\n  uint768m_T re;\n  uint768m_T im;\n} cuint768m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} int832m_T;\n\ntypedef struct {\n  int832m_T re;\n  int832m_T im;\n} cint832m_T;\n\ntypedef struct {\n  uint64_T chunks[13];\n} uint832m_T;\n\ntypedef struct {\n  uint832m_T re;\n  uint832m_T im;\n} cuint832m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} int896m_T;\n\ntypedef struct {\n  int896m_T re;\n  int896m_T im;\n} cint896m_T;\n\ntypedef struct {\n  uint64_T chunks[14];\n} uint896m_T;\n\ntypedef struct {\n  uint896m_T re;\n  uint896m_T im;\n} cuint896m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} int960m_T;\n\ntypedef struct {\n  int960m_T re;\n  int960m_T im;\n} cint960m_T;\n\ntypedef struct {\n  uint64_T chunks[15];\n} uint960m_T;\n\ntypedef struct {\n  uint960m_T re;\n  uint960m_T im;\n} cuint960m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} int1024m_T;\n\ntypedef struct {\n  int1024m_T re;\n  int1024m_T im;\n} cint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[16];\n} uint1024m_T;\n\ntypedef struct {\n  uint1024m_T re;\n  uint1024m_T im;\n} cuint1024m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} int1088m_T;\n\ntypedef struct {\n  int1088m_T re;\n  int1088m_T im;\n} cint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[17];\n} uint1088m_T;\n\ntypedef struct {\n  uint1088m_T re;\n  uint1088m_T im;\n} cuint1088m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} int1152m_T;\n\ntypedef struct {\n  int1152m_T re;\n  int1152m_T im;\n} cint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[18];\n} uint1152m_T;\n\ntypedef struct {\n  uint1152m_T re;\n  uint1152m_T im;\n} cuint1152m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} int1216m_T;\n\ntypedef struct {\n  int1216m_T re;\n  int1216m_T im;\n} cint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[19];\n} uint1216m_T;\n\ntypedef struct {\n  uint1216m_T re;\n  uint1216m_T im;\n} cuint1216m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} int1280m_T;\n\ntypedef struct {\n  int1280m_T re;\n  int1280m_T im;\n} cint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[20];\n} uint1280m_T;\n\ntypedef struct {\n  uint1280m_T re;\n  uint1280m_T im;\n} cuint1280m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} int1344m_T;\n\ntypedef struct {\n  int1344m_T re;\n  int1344m_T im;\n} cint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[21];\n} uint1344m_T;\n\ntypedef struct {\n  uint1344m_T re;\n  uint1344m_T im;\n} cuint1344m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} int1408m_T;\n\ntypedef struct {\n  int1408m_T re;\n  int1408m_T im;\n} cint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[22];\n} uint1408m_T;\n\ntypedef struct {\n  uint1408m_T re;\n  uint1408m_T im;\n} cuint1408m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} int1472m_T;\n\ntypedef struct {\n  int1472m_T re;\n  int1472m_T im;\n} cint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[23];\n} uint1472m_T;\n\ntypedef struct {\n  uint1472m_T re;\n  uint1472m_T im;\n} cuint1472m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} int1536m_T;\n\ntypedef struct {\n  int1536m_T re;\n  int1536m_T im;\n} cint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[24];\n} uint1536m_T;\n\ntypedef struct {\n  uint1536m_T re;\n  uint1536m_T im;\n} cuint1536m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} int1600m_T;\n\ntypedef struct {\n  int1600m_T re;\n  int1600m_T im;\n} cint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[25];\n} uint1600m_T;\n\ntypedef struct {\n  uint1600m_T re;\n  uint1600m_T im;\n} cuint1600m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} int1664m_T;\n\ntypedef struct {\n  int1664m_T re;\n  int1664m_T im;\n} cint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[26];\n} uint1664m_T;\n\ntypedef struct {\n  uint1664m_T re;\n  uint1664m_T im;\n} cuint1664m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} int1728m_T;\n\ntypedef struct {\n  int1728m_T re;\n  int1728m_T im;\n} cint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[27];\n} uint1728m_T;\n\ntypedef struct {\n  uint1728m_T re;\n  uint1728m_T im;\n} cuint1728m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} int1792m_T;\n\ntypedef struct {\n  int1792m_T re;\n  int1792m_T im;\n} cint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[28];\n} uint1792m_T;\n\ntypedef struct {\n  uint1792m_T re;\n  uint1792m_T im;\n} cuint1792m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} int1856m_T;\n\ntypedef struct {\n  int1856m_T re;\n  int1856m_T im;\n} cint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[29];\n} uint1856m_T;\n\ntypedef struct {\n  uint1856m_T re;\n  uint1856m_T im;\n} cuint1856m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} int1920m_T;\n\ntypedef struct {\n  int1920m_T re;\n  int1920m_T im;\n} cint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[30];\n} uint1920m_T;\n\ntypedef struct {\n  uint1920m_T re;\n  uint1920m_T im;\n} cuint1920m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} int1984m_T;\n\ntypedef struct {\n  int1984m_T re;\n  int1984m_T im;\n} cint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[31];\n} uint1984m_T;\n\ntypedef struct {\n  uint1984m_T re;\n  uint1984m_T im;\n} cuint1984m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} int2048m_T;\n\ntypedef struct {\n  int2048m_T re;\n  int2048m_T im;\n} cint2048m_T;\n\ntypedef struct {\n  uint64_T chunks[32];\n} uint2048m_T;\n\ntypedef struct {\n  uint2048m_T re;\n  uint2048m_T im;\n} cuint2048m_T;\n\n#endif                                 /* MULTIWORD_TYPES_H */\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetInf.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        union {\n          LittleEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        inf = tmpVal.fltVal;\n        break;\n      }\n\n     case BigEndian:\n      {\n        union {\n          BigEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0x7FF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        inf = tmpVal.fltVal;\n        break;\n      }\n    }\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        union {\n          LittleEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        minf = tmpVal.fltVal;\n        break;\n      }\n\n     case BigEndian:\n      {\n        union {\n          BigEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0xFFF00000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        minf = tmpVal.fltVal;\n        break;\n      }\n    }\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\n\n        /*\n    * rtGetInf.h\n    *\n            * Academic License - for use in teaching, academic research, and meeting\n* course requirements at degree granting institutions only.  Not for\n* government, commercial, or other organizational use.\n        *\n    * Code generation for model \"bouncing_ball_GT_sf\".\n    *\n    * Model version              : 12.4\n    * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n        * C source code generated on : Wed Apr 16 18:57:52 2025\n * \n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection: \n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n    */\n\n\n    #ifndef rtGetInf_h_\n    #define rtGetInf_h_\n\n\n\n    \n#include \"rt_nonfinite.h\"\n\n#include \"rtwtypes.h\"\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        \n        extern real_T rtGetInf(void);\n            extern real32_T rtGetInfF(void);\n            extern real_T rtGetMinusInf(void);\n            extern real32_T rtGetMinusInfF(void);\n        \n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    #endif /* rtGetInf_h_ */\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtGetNaN.c\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetNaN.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    uint16_T one = 1U;\n    enum {\n      LittleEndian,\n      BigEndian\n    } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n    switch (machByteOrder) {\n     case LittleEndian:\n      {\n        union {\n          LittleEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0xFFF80000U;\n        tmpVal.bitVal.words.wordL = 0x00000000U;\n        nan = tmpVal.fltVal;\n        break;\n      }\n\n     case BigEndian:\n      {\n        union {\n          BigEndianIEEEDouble bitVal;\n          real_T fltVal;\n        } tmpVal;\n\n        tmpVal.bitVal.words.wordH = 0x7FFFFFFFU;\n        tmpVal.bitVal.words.wordL = 0xFFFFFFFFU;\n        nan = tmpVal.fltVal;\n        break;\n      }\n    }\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  uint16_T one = 1U;\n  enum {\n    LittleEndian,\n    BigEndian\n  } machByteOrder = (*((uint8_T *) &one) == 1U) ? LittleEndian : BigEndian;\n  switch (machByteOrder) {\n   case LittleEndian:\n    {\n      nanF.wordL.wordLuint = 0xFFC00000U;\n      break;\n    }\n\n   case BigEndian:\n    {\n      nanF.wordL.wordLuint = 0x7FFFFFFFU;\n      break;\n    }\n  }\n\n  return nanF.wordL.wordLreal;\n}\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\n\n        /*\n    * rtGetNaN.h\n    *\n            * Academic License - for use in teaching, academic research, and meeting\n* course requirements at degree granting institutions only.  Not for\n* government, commercial, or other organizational use.\n        *\n    * Code generation for model \"bouncing_ball_GT_sf\".\n    *\n    * Model version              : 12.4\n    * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n        * C source code generated on : Wed Apr 16 18:57:52 2025\n * \n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection: \n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n    */\n\n\n    #ifndef rtGetNaN_h_\n    #define rtGetNaN_h_\n\n\n\n    \n#include \"rt_nonfinite.h\"\n\n#include \"rtwtypes.h\"\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        \n        extern real_T rtGetNaN(void);\n            extern real32_T rtGetNaNF(void);\n        \n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    #endif /* rtGetNaN_h_ */\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\n\n        /*\n    * rt_defines.h\n    *\n            * Academic License - for use in teaching, academic research, and meeting\n* course requirements at degree granting institutions only.  Not for\n* government, commercial, or other organizational use.\n        *\n    * Code generation for model \"bouncing_ball_GT_sf\".\n    *\n    * Model version              : 12.4\n    * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n        * C source code generated on : Wed Apr 16 18:57:52 2025\n * \n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection: \n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n    */\n\n\n    #ifndef rt_defines_h_\n    #define rt_defines_h_\n\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    /*===========*\n    * Constants *\n    *===========*/\n\n    #define RT_PI          3.14159265358979323846\n    #define RT_PIF         3.1415927F\n    #define RT_LN_10       2.30258509299404568402\n    #define RT_LN_10F      2.3025851F\n    #define RT_LOG10E      0.43429448190325182765\n    #define RT_LOG10EF     0.43429449F\n    #define RT_E           2.7182818284590452354\n    #define RT_EF          2.7182817F\n\n    /*\n    * UNUSED_PARAMETER(x)\n    *   Used to specify that a function parameter (argument) is required but not\n    *   accessed by the function body.\n    */\n    #ifndef UNUSED_PARAMETER\n    #if defined(__LCC__)\n    #define UNUSED_PARAMETER(x)  /* do nothing */\n    #else\n    /*\n    * This is the semi-ANSI standard way of indicating that an\n    * unused function parameter is required.\n    */\n    #define UNUSED_PARAMETER(x) (void) (x)\n    #endif\n    #endif\n\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    #endif /* rt_defines_h_ */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\n\n        /*\n    * rt_nonfinite.c\n    *\n            * Academic License - for use in teaching, academic research, and meeting\n* course requirements at degree granting institutions only.  Not for\n* government, commercial, or other organizational use.\n        *\n    * Code generation for model \"bouncing_ball_GT_sf\".\n    *\n    * Model version              : 12.4\n    * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n        * C source code generated on : Wed Apr 16 18:57:52 2025\n * \n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection: \n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n    */\n\n\n\n\n    \n#include \"rtGetNaN.h\"\n\n#include \"rtGetInf.h\"\n\n#include <stddef.h>\n\n#include \"rtwtypes.h\"\n\n#include \"rt_nonfinite.h\"\n\n\n    \n\n    \n\n    \n\n        #define NumBitsPerChar  8U\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n                real_T rtInf;\n\n\n\n                real_T rtMinusInf;\n\n\n\n                real_T rtNaN;\n\n\n\n                real32_T rtInfF;\n\n\n\n                real32_T rtMinusInfF;\n\n\n\n                real32_T rtNaNF;\n\n\n\n\n\n\n    \n    /* \n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\n\n         void rt_InitInfAndNaN(size_t realSize) {\n\n        (void) (realSize);\n        rtNaN = rtGetNaN();\n        rtNaNF = rtGetNaNF();\n        rtInf = rtGetInf();\n        rtInfF = rtGetInfF();\n        rtMinusInf = rtGetMinusInf();\n        rtMinusInfF = rtGetMinusInfF();\n    }\n    \n    /* Test if value is infinite */\n         boolean_T rtIsInf(real_T value) {\n        return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n    }\n    \n    /* Test if single-precision value is infinite */\n         boolean_T rtIsInfF(real32_T value) {\n        return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n    }\n    \n    /* Test if value is not a number */\n         boolean_T rtIsNaN(real_T value) {\n        boolean_T result = (boolean_T) 0;\n        size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n\n        if (bitsPerReal == 32U) {\n            result = rtIsNaNF((real32_T)value);\n        } else {\n                    \n    union {\n        LittleEndianIEEEDouble bitVal;\n        real_T fltVal;\n    } tmpVal;\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n    ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n    (tmpVal.bitVal.words.wordL != 0) ));\n    \n\n        }\n        return result;\n    }\n    \n    /* Test if single-precision value is not a number */\n         boolean_T rtIsNaNF(real32_T value) {\n        IEEESingle tmp;\n        tmp.wordL.wordLreal = value;\n        return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n        (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n    }\n    \n\n\n    \n\n    \n\n    \n\n    \n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"\n\n        /*\n    * rt_nonfinite.h\n    *\n            * Academic License - for use in teaching, academic research, and meeting\n* course requirements at degree granting institutions only.  Not for\n* government, commercial, or other organizational use.\n        *\n    * Code generation for model \"bouncing_ball_GT_sf\".\n    *\n    * Model version              : 12.4\n    * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n        * C source code generated on : Wed Apr 16 18:57:52 2025\n * \n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection: \n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n    */\n\n\n    #ifndef rt_nonfinite_h_\n    #define rt_nonfinite_h_\n\n\n\n    \n#include <stddef.h>\n\n#include \"rtwtypes.h\"\n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n        #define NOT_USING_NONFINITE_LITERALS 1\n\n    \n                extern real_T rtInf;\n\n\n\n                extern real_T rtMinusInf;\n\n\n\n                extern real_T rtNaN;\n\n\n\n                extern real32_T rtInfF;\n\n\n\n                extern real32_T rtMinusInfF;\n\n\n\n                extern real32_T rtNaNF;\n\n\n\n\n        extern void rt_InitInfAndNaN(size_t realSize);\n            extern boolean_T rtIsInf(real_T value);\n            extern boolean_T rtIsInfF(real32_T value);\n            extern boolean_T rtIsNaN(real_T value);\n            extern boolean_T rtIsNaNF(real32_T value);\n    \n    typedef struct  {\n    struct {\n        uint32_T wordH;\n        uint32_T wordL;\n    } words;\n    } BigEndianIEEEDouble;\n\n    typedef struct  {\n    struct {\n        uint32_T wordL;\n        uint32_T wordH;\n    } words;\n    } LittleEndianIEEEDouble;\n\n    typedef struct  {\n    union {\n        real32_T wordLreal;\n        uint32_T wordLuint;\n    } wordL;\n    } IEEESingle;\n\n    \n\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    #endif /* rt_nonfinite_h_ */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * rtwtypes.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n#include \"tmwtypes.h\"\n#ifndef POINTER_T\n#define POINTER_T\n\ntypedef void * pointer_T;\n\n#endif\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n#ifndef INT64_T\n#define INT64_T\n\ntypedef long int64_T;\n\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#endif\n\n#ifndef UINT64_T\n#define UINT64_T\n\ntypedef unsigned long uint64_T;\n\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n#endif\n\n/*===========================================================================*\n * Additional complex number type definitions                                           *\n *===========================================================================*/\n#ifndef CINT64_T\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#endif\n\n#ifndef CUINT64_T\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n#endif\n#endif                                 /* RTWTYPES_H */\n"},{"name":"bouncing_ball_GT_mid.h","type":"header","group":"interface","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * bouncing_ball_GT_mid.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n *\n * SOURCES: bouncing_ball_GT_sf.c\n */\n\n#if defined(MATLAB_MEX_FILE) || defined(RT_MALLOC)\n\nstatic int_T RegNumInputPorts(SimStruct *S, int_T nInputPorts)\n{\n  _ssSetNumInputPorts(S,nInputPorts);\n  return true;\n}\n\nstatic int_T RegNumOutputPorts(SimStruct *S, int_T nOutputPorts)\n{\n  _ssSetNumOutputPorts(S,nOutputPorts);\n  return true;\n}\n\nstatic int_T FcnSetErrorStatus(const SimStruct *S, DTypeId arg2)\n{\n  static char_T msg[256];\n  if (strlen(ssGetModelName(S)) < 128) {\n    snprintf(msg, sizeof(msg),\n             \"S-function %s does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\",\n             ssGetModelName(S));\n  } else {\n    snprintf(msg, sizeof(msg),\n             \"A S-function does not have a tlc file. It cannot use macros that access regDataType field in simstruct.\");\n  }\n\n  ssSetErrorStatus(S, msg);\n  UNUSED_PARAMETER(arg2);\n  return 0;\n}\n\nstatic void * FcnSetErrorStatusWithReturnPtr(const SimStruct *S, DTypeId arg2)\n{\n  FcnSetErrorStatus(S,0);\n  UNUSED_PARAMETER(arg2);\n  return 0;\n}\n\nstatic int_T FcnSetErrorStatusWithArgPtr(const SimStruct *S, const void* arg2)\n{\n  FcnSetErrorStatus(S,0);\n  UNUSED_PARAMETER(arg2);\n  return 0;\n}\n\n#endif\n\n/* Instance data for model: bouncing_ball_GT */\nvoid *bouncing_ball_GT_malloc(SimStruct *rts)\n{\n  /* Local SimStruct for the generated S-Function */\n  LocalS *lS = (LocalS *) malloc(sizeof(LocalS));\n  ss_VALIDATE_MEMORY(rts,lS);\n  (void) memset((char_T *) lS, 0,\n                sizeof(LocalS));\n  ssSetUserData(rts, lS);\n\n  /* block I/O */\n  {\n    void *b = malloc(sizeof(B_bouncing_ball_GT_T));\n    ss_VALIDATE_MEMORY(rts,b);\n    ssSetLocalBlockIO(rts, b);\n    (void) memset(b, 0,\n                  sizeof(B_bouncing_ball_GT_T));\n  }\n\n  /* model checksums */\n  ssSetChecksumVal(rts, 0, 522743239U);\n  ssSetChecksumVal(rts, 1, 68571262U);\n  ssSetChecksumVal(rts, 2, 1454303353U);\n  ssSetChecksumVal(rts, 3, 2148741027U);\n  return (NULL);\n}\n"},{"name":"bouncing_ball_GT_sid.h","type":"header","group":"interface","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_sfcn_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * bouncing_ball_GT_sid.h\n *\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * Code generation for model \"bouncing_ball_GT_sf\".\n *\n * Model version              : 12.4\n * Simulink Coder version : 24.2 (R2024b) 21-Jun-2024\n * C source code generated on : Wed Apr 16 18:57:52 2025\n *\n * Target selection: rtwsfcn.tlc\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n *\n * SOURCES: bouncing_ball_GT_sf.c\n */\n\n/* statically allocated instance data for model: bouncing_ball_GT */\n{\n  {\n    /* Local SimStruct for the generated S-Function */\n    static LocalS slS;\n    LocalS *lS = &slS;\n    ssSetUserData(rts, lS);\n\n    /* block I/O */\n    {\n      static B_bouncing_ball_GT_T sfcnB;\n      void *b = (real_T *) &sfcnB;\n      ssSetLocalBlockIO(rts, b);\n      (void) memset(b, 0,\n                    sizeof(B_bouncing_ball_GT_T));\n    }\n\n    /* model checksums */\n    ssSetChecksumVal(rts, 0, 522743239U);\n    ssSetChecksumVal(rts, 1, 68571262U);\n    ssSetChecksumVal(rts, 2, 1454303353U);\n    ssSetChecksumVal(rts, 3, 2148741027U);\n  }\n}\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};