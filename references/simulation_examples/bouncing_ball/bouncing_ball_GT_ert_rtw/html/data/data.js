var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"bouncing_ball_GT","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"bouncing_ball_GT.h\"          /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    rtmSetErrorStatus(bouncing_ball_GT_M, \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  bouncing_ball_GT_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  bouncing_ball_GT_initialize();\n\n  /* Simulating the model step behavior (in non real-time) to\n   *  simulate model behavior at stop time.\n   */\n  while (rtmGetErrorStatus(bouncing_ball_GT_M) == (NULL)&& !rtmGetStopRequested\n         (bouncing_ball_GT_M)) {\n    rt_OneStep();\n  }\n\n  /* Terminate model */\n  bouncing_ball_GT_terminate();\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bouncing_ball_GT.c","type":"source","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bouncing_ball_GT.c\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"bouncing_ball_GT.h\"\n#include \"rtwtypes.h\"\n#include \"bouncing_ball_GT_private.h\"\n#include \"rt_nonfinite.h\"\n\n/* Block signals (default storage) */\nB_bouncing_ball_GT_T bouncing_ball_GT_B;\n\n/* Continuous states */\nX_bouncing_ball_GT_T bouncing_ball_GT_X;\n\n/* Disabled State Vector */\nXDis_bouncing_ball_GT_T bouncing_ball_GT_XDis;\n\n/* Block states (default storage) */\nDW_bouncing_ball_GT_T bouncing_ball_GT_DW;\n\n/* Real-time model */\nstatic RT_MODEL_bouncing_ball_GT_T bouncing_ball_GT_M_;\nRT_MODEL_bouncing_ball_GT_T *const bouncing_ball_GT_M = &bouncing_ball_GT_M_;\n\n/*\n * This function updates continuous states using the ODE3 fixed-step\n * solver algorithm\n */\nstatic void rt_ertODEUpdateContinuousStates(RTWSolverInfo *si )\n{\n  /* Solver Matrices */\n  static const real_T rt_ODE3_A[3] = {\n    1.0/2.0, 3.0/4.0, 1.0\n  };\n\n  static const real_T rt_ODE3_B[3][3] = {\n    { 1.0/2.0, 0.0, 0.0 },\n\n    { 0.0, 3.0/4.0, 0.0 },\n\n    { 2.0/9.0, 1.0/3.0, 4.0/9.0 }\n  };\n\n  time_T t = rtsiGetT(si);\n  time_T tnew = rtsiGetSolverStopTime(si);\n  time_T h = rtsiGetStepSize(si);\n  real_T *x = rtsiGetContStates(si);\n  ODE3_IntgData *id = (ODE3_IntgData *)rtsiGetSolverData(si);\n  real_T *y = id->y;\n  real_T *f0 = id->f[0];\n  real_T *f1 = id->f[1];\n  real_T *f2 = id->f[2];\n  real_T hB[3];\n  int_T i;\n  int_T nXc = 2;\n  rtsiSetSimTimeStep(si,MINOR_TIME_STEP);\n\n  /* Save the state values at time t in y, we'll use x as ynew. */\n  (void) memcpy(y, x,\n                (uint_T)nXc*sizeof(real_T));\n\n  /* Assumes that rtsiSetT and ModelOutputs are up-to-date */\n  /* f0 = f(t,y) */\n  rtsiSetdX(si, f0);\n  bouncing_ball_GT_derivatives();\n\n  /* f(:,2) = feval(odefile, t + hA(1), y + f*hB(:,1), args(:)(*)); */\n  hB[0] = h * rt_ODE3_B[0][0];\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[0]);\n  rtsiSetdX(si, f1);\n  bouncing_ball_GT_step();\n  bouncing_ball_GT_derivatives();\n\n  /* f(:,3) = feval(odefile, t + hA(2), y + f*hB(:,2), args(:)(*)); */\n  for (i = 0; i <= 1; i++) {\n    hB[i] = h * rt_ODE3_B[1][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1]);\n  }\n\n  rtsiSetT(si, t + h*rt_ODE3_A[1]);\n  rtsiSetdX(si, f2);\n  bouncing_ball_GT_step();\n  bouncing_ball_GT_derivatives();\n\n  /* tnew = t + hA(3);\n     ynew = y + f*hB(:,3); */\n  for (i = 0; i <= 2; i++) {\n    hB[i] = h * rt_ODE3_B[2][i];\n  }\n\n  for (i = 0; i < nXc; i++) {\n    x[i] = y[i] + (f0[i]*hB[0] + f1[i]*hB[1] + f2[i]*hB[2]);\n  }\n\n  rtsiSetT(si, tnew);\n  rtsiSetSimTimeStep(si,MAJOR_TIME_STEP);\n}\n\n/* Model step function */\nvoid bouncing_ball_GT_step(void)\n{\n  int32_T uMode;\n  if (rtmIsMajorTimeStep(bouncing_ball_GT_M)) {\n    /* set solver stop time */\n    rtsiSetSolverStopTime(&bouncing_ball_GT_M->solverInfo,\n                          ((bouncing_ball_GT_M->Timing.clockTick0+1)*\n      bouncing_ball_GT_M->Timing.stepSize0));\n  }                                    /* end MajorTimeStep */\n\n  /* Update absolute time of base rate at minor time step */\n  if (rtmIsMinorTimeStep(bouncing_ball_GT_M)) {\n    bouncing_ball_GT_M->Timing.t[0] = rtsiGetT(&bouncing_ball_GT_M->solverInfo);\n  }\n\n  if (rtmIsMajorTimeStep(bouncing_ball_GT_M)) {\n    /* InitialCondition: '<Root>/Initial Velocity (IC) ' */\n    if (bouncing_ball_GT_DW.InitialVelocityIC_FirstOutputTi) {\n      bouncing_ball_GT_DW.InitialVelocityIC_FirstOutputTi = false;\n\n      /* InitialCondition: '<Root>/Initial Velocity (IC) ' */\n      bouncing_ball_GT_B.InitialVelocityIC = 0.0;\n    } else {\n      /* InitialCondition: '<Root>/Initial Velocity (IC) ' incorporates:\n       *  Gain: '<Root>/Coefficient of  Restitution'\n       *  Memory: '<Root>/Memory'\n       */\n      bouncing_ball_GT_B.InitialVelocityIC = -0.8 *\n        bouncing_ball_GT_DW.Memory_PreviousInput;\n    }\n\n    /* End of InitialCondition: '<Root>/Initial Velocity (IC) ' */\n  }\n\n  /* SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n  if (bouncing_ball_GT_DW.SecondOrderIntegrator_DWORK1) {\n    bouncing_ball_GT_X.Position[1] = bouncing_ball_GT_B.InitialVelocityIC;\n  }\n\n  if (rtsiIsModeUpdateTimeStep(&bouncing_ball_GT_M->solverInfo)) {\n    switch (bouncing_ball_GT_DW.SecondOrderIntegrator_MODE) {\n     case 0:\n      if (bouncing_ball_GT_X.Position[0] <= 0.0) {\n        bouncing_ball_GT_X.Position[0] = 0.0;\n        if (bouncing_ball_GT_X.Position[1] > 0.0) {\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 0;\n        } else {\n          bouncing_ball_GT_X.Position[1] = 0.0;\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 1;\n        }\n\n        if (bouncing_ball_GT_B.InitialVelocityIC > 0.0) {\n          bouncing_ball_GT_X.Position[1] = bouncing_ball_GT_B.InitialVelocityIC;\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 0;\n        }\n\n        rtsiSetBlockStateForSolverChangedAtMajorStep\n          (&bouncing_ball_GT_M->solverInfo, true);\n      }\n\n      if (bouncing_ball_GT_X.Position[0] >= (rtInf)) {\n        bouncing_ball_GT_X.Position[0] = (rtInf);\n        if (bouncing_ball_GT_X.Position[1] < 0.0) {\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 0;\n        } else {\n          bouncing_ball_GT_X.Position[1] = 0.0;\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 2;\n        }\n\n        if (bouncing_ball_GT_B.InitialVelocityIC < 0.0) {\n          bouncing_ball_GT_X.Position[1] = bouncing_ball_GT_B.InitialVelocityIC;\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 0;\n        }\n\n        rtsiSetBlockStateForSolverChangedAtMajorStep\n          (&bouncing_ball_GT_M->solverInfo, true);\n      }\n      break;\n\n     case 1:\n      if (bouncing_ball_GT_X.Position[0] > 0.0) {\n        if (bouncing_ball_GT_X.Position[0] >= (rtInf)) {\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 2;\n          bouncing_ball_GT_X.Position[0] = (rtInf);\n        } else {\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 0;\n        }\n      } else {\n        bouncing_ball_GT_X.Position[0] = 0.0;\n        bouncing_ball_GT_X.Position[1] = 0.0;\n      }\n      break;\n\n     case 2:\n      if (bouncing_ball_GT_X.Position[0] < (rtInf)) {\n        if (bouncing_ball_GT_X.Position[0] <= 0.0) {\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 1;\n          bouncing_ball_GT_X.Position[0] = 0.0;\n        } else {\n          bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = 0;\n        }\n      } else {\n        bouncing_ball_GT_X.Position[0] = (rtInf);\n        bouncing_ball_GT_X.Position[1] = 0.0;\n      }\n      break;\n    }\n  }\n\n  /* SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n  bouncing_ball_GT_B.Velocity = bouncing_ball_GT_X.Position[1];\n  if (rtmIsMajorTimeStep(bouncing_ball_GT_M)) {\n    if (rtmIsMajorTimeStep(bouncing_ball_GT_M)) {\n      /* Update for Memory: '<Root>/Memory' */\n      bouncing_ball_GT_DW.Memory_PreviousInput = bouncing_ball_GT_B.Velocity;\n    }\n\n    /* Update for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n    bouncing_ball_GT_DW.SecondOrderIntegrator_DWORK1 = false;\n    uMode = bouncing_ball_GT_DW.SecondOrderIntegrator_MODE;\n    if (bouncing_ball_GT_DW.SecondOrderIntegrator_MODE == 2) {\n      uMode = 0;\n    }\n\n    if (bouncing_ball_GT_DW.SecondOrderIntegrator_MODE != uMode) {\n      bouncing_ball_GT_DW.SecondOrderIntegrator_MODE = uMode;\n      rtsiSetBlockStateForSolverChangedAtMajorStep\n        (&bouncing_ball_GT_M->solverInfo, true);\n    }\n\n    /* End of Update for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n  }                                    /* end MajorTimeStep */\n\n  if (rtmIsMajorTimeStep(bouncing_ball_GT_M)) {\n    rt_ertODEUpdateContinuousStates(&bouncing_ball_GT_M->solverInfo);\n\n    /* Update absolute time for base rate */\n    /* The \"clockTick0\" counts the number of times the code of this task has\n     * been executed. The absolute time is the multiplication of \"clockTick0\"\n     * and \"Timing.stepSize0\". Size of \"clockTick0\" ensures timer will not\n     * overflow during the application lifespan selected.\n     */\n    ++bouncing_ball_GT_M->Timing.clockTick0;\n    bouncing_ball_GT_M->Timing.t[0] = rtsiGetSolverStopTime\n      (&bouncing_ball_GT_M->solverInfo);\n\n    {\n      /* Update absolute timer for sample time: [0.5s, 0.0s] */\n      /* The \"clockTick1\" counts the number of times the code of this task has\n       * been executed. The resolution of this integer timer is 0.5, which is the step size\n       * of the task. Size of \"clockTick1\" ensures timer will not overflow during the\n       * application lifespan selected.\n       */\n      bouncing_ball_GT_M->Timing.clockTick1++;\n    }\n  }                                    /* end MajorTimeStep */\n}\n\n/* Derivatives for root system: '<Root>' */\nvoid bouncing_ball_GT_derivatives(void)\n{\n  XDot_bouncing_ball_GT_T *_rtXdot;\n  _rtXdot = ((XDot_bouncing_ball_GT_T *) bouncing_ball_GT_M->derivs);\n\n  /* Derivatives for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' incorporates:\n   *  Constant: '<Root>/Gravitational acceleration'\n   */\n  switch (bouncing_ball_GT_DW.SecondOrderIntegrator_MODE) {\n   case 0:\n    _rtXdot->Position[0] = bouncing_ball_GT_X.Position[1];\n    _rtXdot->Position[1] = -9.81;\n    break;\n\n   case 1:\n    _rtXdot->Position[0] = 0.0;\n    _rtXdot->Position[1] = 0.0;\n    break;\n\n   case 2:\n    _rtXdot->Position[0] = 0.0;\n    _rtXdot->Position[1] = 0.0;\n    break;\n  }\n\n  /* End of Derivatives for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n}\n\n/* Model initialize function */\nvoid bouncing_ball_GT_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    /* Setup solver object */\n    rtsiSetSimTimeStepPtr(&bouncing_ball_GT_M->solverInfo,\n                          &bouncing_ball_GT_M->Timing.simTimeStep);\n    rtsiSetTPtr(&bouncing_ball_GT_M->solverInfo, &rtmGetTPtr(bouncing_ball_GT_M));\n    rtsiSetStepSizePtr(&bouncing_ball_GT_M->solverInfo,\n                       &bouncing_ball_GT_M->Timing.stepSize0);\n    rtsiSetdXPtr(&bouncing_ball_GT_M->solverInfo, &bouncing_ball_GT_M->derivs);\n    rtsiSetContStatesPtr(&bouncing_ball_GT_M->solverInfo, (real_T **)\n                         &bouncing_ball_GT_M->contStates);\n    rtsiSetNumContStatesPtr(&bouncing_ball_GT_M->solverInfo,\n      &bouncing_ball_GT_M->Sizes.numContStates);\n    rtsiSetNumPeriodicContStatesPtr(&bouncing_ball_GT_M->solverInfo,\n      &bouncing_ball_GT_M->Sizes.numPeriodicContStates);\n    rtsiSetPeriodicContStateIndicesPtr(&bouncing_ball_GT_M->solverInfo,\n      &bouncing_ball_GT_M->periodicContStateIndices);\n    rtsiSetPeriodicContStateRangesPtr(&bouncing_ball_GT_M->solverInfo,\n      &bouncing_ball_GT_M->periodicContStateRanges);\n    rtsiSetContStateDisabledPtr(&bouncing_ball_GT_M->solverInfo, (boolean_T**)\n      &bouncing_ball_GT_M->contStateDisabled);\n    rtsiSetErrorStatusPtr(&bouncing_ball_GT_M->solverInfo, (&rtmGetErrorStatus\n      (bouncing_ball_GT_M)));\n    rtsiSetRTModelPtr(&bouncing_ball_GT_M->solverInfo, bouncing_ball_GT_M);\n  }\n\n  rtsiSetSimTimeStep(&bouncing_ball_GT_M->solverInfo, MAJOR_TIME_STEP);\n  rtsiSetIsMinorTimeStepWithModeChange(&bouncing_ball_GT_M->solverInfo, false);\n  rtsiSetIsContModeFrozen(&bouncing_ball_GT_M->solverInfo, false);\n  bouncing_ball_GT_M->intgData.y = bouncing_ball_GT_M->odeY;\n  bouncing_ball_GT_M->intgData.f[0] = bouncing_ball_GT_M->odeF[0];\n  bouncing_ball_GT_M->intgData.f[1] = bouncing_ball_GT_M->odeF[1];\n  bouncing_ball_GT_M->intgData.f[2] = bouncing_ball_GT_M->odeF[2];\n  bouncing_ball_GT_M->contStates = ((X_bouncing_ball_GT_T *) &bouncing_ball_GT_X);\n  bouncing_ball_GT_M->contStateDisabled = ((XDis_bouncing_ball_GT_T *)\n    &bouncing_ball_GT_XDis);\n  bouncing_ball_GT_M->Timing.tStart = (0.0);\n  rtsiSetSolverData(&bouncing_ball_GT_M->solverInfo, (void *)\n                    &bouncing_ball_GT_M->intgData);\n  rtsiSetSolverName(&bouncing_ball_GT_M->solverInfo,\"ode3\");\n  rtmSetTPtr(bouncing_ball_GT_M, &bouncing_ball_GT_M->Timing.tArray[0]);\n  bouncing_ball_GT_M->Timing.stepSize0 = 0.5;\n\n  /* Start for InitialCondition: '<Root>/Initial Velocity (IC) ' */\n  bouncing_ball_GT_DW.InitialVelocityIC_FirstOutputTi = true;\n\n  /* InitializeConditions for SecondOrderIntegrator: '<Root>/Second-Order  Integrator' */\n  bouncing_ball_GT_X.Position[0] = 25.0;\n  bouncing_ball_GT_DW.SecondOrderIntegrator_DWORK1 = true;\n}\n\n/* Model terminate function */\nvoid bouncing_ball_GT_terminate(void)\n{\n  /* (no terminate code required) */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bouncing_ball_GT.h","type":"header","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bouncing_ball_GT.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bouncing_ball_GT_h_\n#define bouncing_ball_GT_h_\n#ifndef bouncing_ball_GT_COMMON_INCLUDES_\n#define bouncing_ball_GT_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n#endif                                 /* bouncing_ball_GT_COMMON_INCLUDES_ */\n\n#include \"bouncing_ball_GT_types.h\"\n#include \"rt_nonfinite.h\"\n#include \"rtGetInf.h\"\n#include <string.h>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmGetT\n#define rtmGetT(rtm)                   (rtmGetTPtr((rtm))[0])\n#endif\n\n#ifndef rtmGetTPtr\n#define rtmGetTPtr(rtm)                ((rtm)->Timing.t)\n#endif\n\n#ifndef rtmGetTStart\n#define rtmGetTStart(rtm)              ((rtm)->Timing.tStart)\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  real_T InitialVelocityIC;            /* '<Root>/Initial Velocity (IC) ' */\n  real_T Velocity;                     /* '<Root>/Second-Order  Integrator' */\n} B_bouncing_ball_GT_T;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  real_T Memory_PreviousInput;         /* '<Root>/Memory' */\n  int_T SecondOrderIntegrator_MODE;    /* '<Root>/Second-Order  Integrator' */\n  boolean_T InitialVelocityIC_FirstOutputTi;/* '<Root>/Initial Velocity (IC) ' */\n  boolean_T SecondOrderIntegrator_DWORK1;/* '<Root>/Second-Order  Integrator' */\n} DW_bouncing_ball_GT_T;\n\n/* Continuous states (default storage) */\ntypedef struct {\n  real_T Position[2];                  /* '<Root>/Second-Order  Integrator' */\n} X_bouncing_ball_GT_T;\n\n/* State derivatives (default storage) */\ntypedef struct {\n  real_T Position[2];                  /* '<Root>/Second-Order  Integrator' */\n} XDot_bouncing_ball_GT_T;\n\n/* State disabled  */\ntypedef struct {\n  boolean_T Position[2];               /* '<Root>/Second-Order  Integrator' */\n} XDis_bouncing_ball_GT_T;\n\n#ifndef ODE3_INTG\n#define ODE3_INTG\n\n/* ODE3 Integration Data */\ntypedef struct {\n  real_T *y;                           /* output */\n  real_T *f[3];                        /* derivatives */\n} ODE3_IntgData;\n\n#endif\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_bouncing_ball_GT_T {\n  const char_T *errorStatus;\n  RTWSolverInfo solverInfo;\n  X_bouncing_ball_GT_T *contStates;\n  int_T *periodicContStateIndices;\n  real_T *periodicContStateRanges;\n  real_T *derivs;\n  XDis_bouncing_ball_GT_T *contStateDisabled;\n  boolean_T zCCacheNeedsReset;\n  boolean_T derivCacheNeedsReset;\n  boolean_T CTOutputIncnstWithState;\n  real_T odeY[2];\n  real_T odeF[3][2];\n  ODE3_IntgData intgData;\n\n  /*\n   * Sizes:\n   * The following substructure contains sizes information\n   * for many of the model attributes such as inputs, outputs,\n   * dwork, sample times, etc.\n   */\n  struct {\n    int_T numContStates;\n    int_T numPeriodicContStates;\n    int_T numSampTimes;\n  } Sizes;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    uint32_T clockTick0;\n    time_T stepSize0;\n    uint32_T clockTick1;\n    time_T tStart;\n    SimTimeStep simTimeStep;\n    boolean_T stopRequestedFlag;\n    time_T *t;\n    time_T tArray[2];\n  } Timing;\n};\n\n/* Block signals (default storage) */\nextern B_bouncing_ball_GT_T bouncing_ball_GT_B;\n\n/* Continuous states (default storage) */\nextern X_bouncing_ball_GT_T bouncing_ball_GT_X;\n\n/* Disabled states (default storage) */\nextern XDis_bouncing_ball_GT_T bouncing_ball_GT_XDis;\n\n/* Block states (default storage) */\nextern DW_bouncing_ball_GT_T bouncing_ball_GT_DW;\n\n/* Model entry point functions */\nextern void bouncing_ball_GT_initialize(void);\nextern void bouncing_ball_GT_step(void);\nextern void bouncing_ball_GT_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_bouncing_ball_GT_T *const bouncing_ball_GT_M;\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<Root>/Scope1' : Unused code path elimination\n * Block '<Root>/Scope2' : Unused code path elimination\n * Block '<Root>/Scope' : Unused code path elimination\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'bouncing_ball_GT'\n */\n#endif                                 /* bouncing_ball_GT_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bouncing_ball_GT_private.h","type":"header","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bouncing_ball_GT_private.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bouncing_ball_GT_private_h_\n#define bouncing_ball_GT_private_h_\n#include \"rtwtypes.h\"\n#include \"bouncing_ball_GT_types.h\"\n#include \"rtw_continuous.h\"\n#include \"rtw_solver.h\"\n\n/* Private macros used by the generated code to access rtModel */\n#ifndef rtmIsMajorTimeStep\n#define rtmIsMajorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MAJOR_TIME_STEP)\n#endif\n\n#ifndef rtmIsMinorTimeStep\n#define rtmIsMinorTimeStep(rtm)        (((rtm)->Timing.simTimeStep) == MINOR_TIME_STEP)\n#endif\n\n#ifndef rtmSetTPtr\n#define rtmSetTPtr(rtm, val)           ((rtm)->Timing.t = (val))\n#endif\n\n/* private model entry point functions */\nextern void bouncing_ball_GT_derivatives(void);\n\n#endif                                 /* bouncing_ball_GT_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bouncing_ball_GT_types.h","type":"header","group":"model","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bouncing_ball_GT_types.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bouncing_ball_GT_types_h_\n#define bouncing_ball_GT_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_bouncing_ball_GT_T RT_MODEL_bouncing_ball_GT_T;\n\n#endif                                 /* bouncing_ball_GT_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.c\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    inf = tmpVal.fltVal;\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    minf = tmpVal.fltVal;\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtGetInf_h_\n#define rtGetInf_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetInf(void);\nextern real32_T rtGetInfF(void);\nextern real_T rtGetMinusInf(void);\nextern real32_T rtGetMinusInfF(void);\n\n#endif                                 /* rtGetInf_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.c\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetNaN.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    nan = tmpVal.fltVal;\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  nanF.wordL.wordLuint = 0xFFC00000U;\n  return nanF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtGetNaN_h_\n#define rtGetNaN_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetNaN(void);\nextern real32_T rtGetNaNF(void);\n\n#endif                                 /* rtGetNaN_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.c\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtGetNaN.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\nreal_T rtInf;\nreal_T rtMinusInf;\nreal_T rtNaN;\nreal32_T rtInfF;\nreal32_T rtMinusInfF;\nreal32_T rtNaNF;\n\n/*\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\nvoid rt_InitInfAndNaN(size_t realSize)\n{\n  (void) (realSize);\n  rtNaN = rtGetNaN();\n  rtNaNF = rtGetNaNF();\n  rtInf = rtGetInf();\n  rtInfF = rtGetInfF();\n  rtMinusInf = rtGetMinusInf();\n  rtMinusInfF = rtGetMinusInfF();\n}\n\n/* Test if value is infinite */\nboolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nboolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nboolean_T rtIsNaN(real_T value)\n{\n  boolean_T result = (boolean_T) 0;\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  if (bitsPerReal == 32U) {\n    result = rtIsNaNF((real32_T)value);\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                          (tmpVal.bitVal.words.wordL != 0) ));\n  }\n\n  return result;\n}\n\n/* Test if single-precision value is not a number */\nboolean_T rtIsNaNF(real32_T value)\n{\n  IEEESingle tmp;\n  tmp.wordL.wordLreal = value;\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nextern void rt_InitInfAndNaN(size_t realSize);\nextern boolean_T rtIsInf(real_T value);\nextern boolean_T rtIsInfF(real32_T value);\nextern boolean_T rtIsNaN(real_T value);\nextern boolean_T rtIsNaNF(real32_T value);\ntypedef struct {\n  struct {\n    uint32_T wordH;\n    uint32_T wordL;\n  } words;\n} BigEndianIEEEDouble;\n\ntypedef struct {\n  struct {\n    uint32_T wordL;\n    uint32_T wordH;\n  } words;\n} LittleEndianIEEEDouble;\n\ntypedef struct {\n  union {\n    real32_T wordLreal;\n    uint32_T wordLuint;\n  } wordL;\n} IEEESingle;\n\n#endif                                 /* rt_nonfinite_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/xinxing/Autosim/references/simulation_examples/bouncing_ball/bouncing_ball_GT_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'bouncing_ball_GT'.\n *\n * Model version                  : 12.4\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Apr 16 18:27:09 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: 32-bit Generic\n * Emulation hardware selection:\n *    Differs from embedded hardware (MATLAB Host)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: MATLAB Host\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  64    long long:  64\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};